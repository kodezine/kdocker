name: Test Docker Image

on:
  push:
    branches:
      - main
      - develop
  pull_request:
    branches:
      - main

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64
          load: true
          tags: cpp-arm-dev:test
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Install and Test ARM Toolchains
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            echo 'Installing ARM toolchains for testing...'
            # Install GNU ARM toolchain (non-interactive)
            echo '2' | stm32-tools gnuarm
            echo 'GNU ARM installation complete'

            # Install ATFE toolchain (non-interactive)
            echo '2' | stm32-tools atfe
            echo 'ATFE installation complete'

            echo ''
            echo 'Verifying ARM toolchain installations...'
            echo 'GNU ARM toolchain:'
            ls -la /home/kdev/gnuarm14.3/bin/arm-none-eabi-gcc
            echo 'ATFE toolchain:'
            ls -la /home/kdev/atfe21.1/bin/clang

            echo ''
            echo 'Testing ARM toolchain versions...'
            /home/kdev/gnuarm14.3/bin/arm-none-eabi-gcc --version
            /home/kdev/atfe21.1/bin/clang --version

            echo ''
            echo 'Testing ARM cross-compilation...'
            echo 'int main(){return 0;}' > /tmp/test.c
            /home/kdev/gnuarm14.3/bin/arm-none-eabi-gcc -mcpu=cortex-m4 -mthumb --specs=nosys.specs -o /tmp/test.elf /tmp/test.c
            file /tmp/test.elf
            echo 'ARM cross-compilation: SUCCESS'

            echo ''
            echo 'Verifying symlinks:'
            ls -la /home/kdev/atfe21.1
            ls -la /home/kdev/gnuarm14.3

            echo ''
            echo 'Toolchain status:'
            stm32-tools status | grep -A10 'ARM Toolchains'
          "

      - name: Install STM32 Debug Tools
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            echo 'Installing STM32 debug and development tools...'
            stm32-tools devtools
            stm32-tools status
          "
      - name: Test bootstrapped ARM GCC
        run: |
          docker run --rm --user kdev cpp-arm-dev:test zsh -c "
            /home/kdev/gnuarm14.3/bin/arm-none-eabi-gcc --version
          "
      - name: Test bootstrapped ATfE
        run: |
          docker run --rm --user kdev cpp-arm-dev:test zsh -c "
            /home/kdev/atfe21.1/bin/clang --version
          "
      - name: Test GCC version and variants
        run: |
          echo "Testing GCC 14 installation and configuration..."
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            echo '=== GCC Version ==='
            gcc --version | head -1
            g++ --version | head -1
            gcov --version | head -1

            echo ''
            echo '=== Verify GCC 14 ==='
            gcc --version | grep -q 'gcc (Ubuntu.*) 14\.' && echo 'SUCCESS: GCC 14.x detected' || { echo 'FAIL: GCC 14 not found'; exit 1; }
            g++ --version | grep -q 'g++ (Ubuntu.*) 14\.' && echo 'SUCCESS: G++ 14.x detected' || { echo 'FAIL: G++ 14 not found'; exit 1; }

            echo ''
            echo '=== Verify Update Alternatives ==='
            update-alternatives --query gcc | grep 'Value: /usr/bin/gcc-14' && echo 'SUCCESS: gcc points to gcc-14' || { echo 'FAIL: gcc not pointing to gcc-14'; exit 1; }
            update-alternatives --query g++ | grep 'Value: /usr/bin/g++-14' && echo 'SUCCESS: g++ points to g++-14' || { echo 'FAIL: g++ not pointing to g++-14'; exit 1; }

            echo ''
            echo '=== Verify GCC 14 Files ==='
            which gcc-14 && echo 'SUCCESS: gcc-14 found in PATH' || { echo 'FAIL: gcc-14 not in PATH'; exit 1; }
            which g++-14 && echo 'SUCCESS: g++-14 found in PATH' || { echo 'FAIL: g++-14 not in PATH'; exit 1; }
            /usr/bin/gcc-14 --version | head -1
            /usr/bin/g++-14 --version | head -1
          "

      - name: Test CMake
        run: docker run --rm --user kdev cpp-arm-dev:test cmake --version

      - name: Test Python
        run: |
          docker run --rm --user kdev cpp-arm-dev:test python --version
          docker run --rm --user kdev cpp-arm-dev:test python -m pip --version

      - name: Test Ruby and Perl
        run: |
          docker run --rm --user kdev cpp-arm-dev:test ruby --version
          docker run --rm --user kdev cpp-arm-dev:test perl --version

      - name: Test gcovr
        run: docker run --rm --user kdev cpp-arm-dev:test gcovr --version

      - name: Test pre-commit availability
        run: |
          docker run --rm --user kdev cpp-arm-dev:test pre-commit --version
          docker run --rm --user kdev cpp-arm-dev:test which pre-commit

      - name: Test setup-pre-commit script exists
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            test -f /home/kdev/.local/bin/setup-pre-commit && echo 'SUCCESS: setup-pre-commit exists' || { echo 'FAIL: setup-pre-commit missing'; exit 1; }
            test -x /home/kdev/.local/bin/setup-pre-commit && echo 'SUCCESS: setup-pre-commit is executable' || { echo 'FAIL: setup-pre-commit not executable'; exit 1; }
          "

      - name: Test setup-pre-commit with no git repo
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            mkdir -p /tmp/no-git
            setup-pre-commit /tmp/no-git | tee /tmp/output.log
            grep -q 'No git repository' /tmp/output.log && echo 'SUCCESS: Handles non-git directories' || { echo 'FAIL: Should detect non-git directory'; exit 1; }
          "

      - name: Test setup-pre-commit with git repo but no config
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            cd /tmp
            rm -rf test-no-config
            mkdir -p test-no-config
            cd test-no-config
            git init
            git config user.email 'test@example.com'
            git config user.name 'Test User'
            setup-pre-commit /tmp/test-no-config | tee /tmp/output2.log
            grep -q 'No .pre-commit-config.yaml found' /tmp/output2.log && echo 'SUCCESS: Handles missing config file' || { echo 'FAIL: Should detect missing config'; exit 1; }
          "

      - name: Test setup-pre-commit installs hooks
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            cd /tmp
            rm -rf test-with-config
            mkdir -p test-with-config
            cd test-with-config
            git init
            git config user.email 'test@example.com'
            git config user.name 'Test User'

            # Create minimal pre-commit config
            cat > .pre-commit-config.yaml << 'EOF'
          repos:
            - repo: https://github.com/pre-commit/pre-commit-hooks
              rev: v4.5.0
              hooks:
                - id: trailing-whitespace
                - id: end-of-file-fixer
          EOF

            # Run setup
            setup-pre-commit /tmp/test-with-config

            # Verify hooks installed
            test -f .git/hooks/pre-commit && echo 'SUCCESS: pre-commit hook file created' || { echo 'FAIL: Hook file missing'; exit 1; }
            grep -q 'pre-commit' .git/hooks/pre-commit && echo 'SUCCESS: Hook file contains pre-commit' || { echo 'FAIL: Hook file invalid'; exit 1; }
          "

      - name: Test setup-pre-commit idempotency
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            cd /tmp
            rm -rf test-idempotent
            mkdir -p test-idempotent
            cd test-idempotent
            git init
            git config user.email 'test@example.com'
            git config user.name 'Test User'

            cat > .pre-commit-config.yaml << 'EOF'
          repos:
            - repo: https://github.com/pre-commit/pre-commit-hooks
              rev: v4.5.0
              hooks:
                - id: trailing-whitespace
          EOF

            # Run setup twice
            setup-pre-commit /tmp/test-idempotent
            setup-pre-commit /tmp/test-idempotent | tee /tmp/output3.log

            # Second run should detect existing installation
            grep -q 'already installed' /tmp/output3.log && echo 'SUCCESS: Idempotent behavior confirmed' || { echo 'FAIL: Should detect existing hooks'; exit 1; }
          "

      - name: Test pre-commit hooks execute
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            cd /tmp
            rm -rf test-hook-exec
            mkdir -p test-hook-exec
            cd test-hook-exec
            git init
            git config user.email 'test@example.com'
            git config user.name 'Test User'

            cat > .pre-commit-config.yaml << 'EOF'
          repos:
            - repo: https://github.com/pre-commit/pre-commit-hooks
              rev: v4.5.0
              hooks:
                - id: trailing-whitespace
          EOF

            setup-pre-commit /tmp/test-hook-exec

            # Create file with trailing whitespace
            echo 'content with trailing whitespace    ' > test.txt
            git add test.txt

            # Hooks should run (and fix the whitespace)
            git commit -m 'test' || echo 'Hooks executed'

            echo 'SUCCESS: Pre-commit hooks can execute'
          "

      - name: Test pyenv NOT pre-installed (should fail)
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            ! command -v pyenv >/dev/null 2>&1 && echo 'SUCCESS: pyenv not pre-installed as expected' || { echo 'FAIL: pyenv should not be pre-installed'; exit 1; }
          "

      - name: Test pyenv dependencies NOT pre-installed
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            # These packages should NOT be installed in base image (they'll be installed by bootstrap)
            ! dpkg -l | grep -q libssl-dev && echo 'SUCCESS: pyenv dependencies not pre-installed' || { echo 'FAIL: pyenv dependencies should not be pre-installed'; exit 1; }
          "

      - name: Test pyenv bootstrap script exists
        run: |
          docker run --rm --user kdev -v ${{ github.workspace }}:/home/kdev/workspaces cpp-arm-dev:test bash -c "
            test -f /home/kdev/workspaces/.devcontainer/bootstrap-pyenv.sh && echo 'SUCCESS: Bootstrap script exists' || { echo 'FAIL: Bootstrap script missing'; exit 1; }
          "

      - name: Test pyenv bootstrap installation
        run: |
          docker run --rm --user kdev -v ${{ github.workspace }}:/home/kdev/workspaces cpp-arm-dev:test bash -c "
            # Copy and run bootstrap script
            cp /home/kdev/workspaces/.devcontainer/bootstrap-pyenv.sh /tmp/
            chmod +x /tmp/bootstrap-pyenv.sh
            /tmp/bootstrap-pyenv.sh

            # Verify pyenv is installed and functional
            source ~/.zshrc
            export PYENV_ROOT=\"\$HOME/.pyenv\"
            export PATH=\"\$PYENV_ROOT/bin:\$PATH\"
            eval \"\$(pyenv init -)\"

            pyenv --version
            pyenv install --list | head -5
            echo 'SUCCESS: pyenv bootstrap completed'
          "

      - name: Test pyenv dependencies installed by bootstrap
        run: |
          docker run --rm --user kdev -v ${{ github.workspace }}:/home/kdev/workspaces cpp-arm-dev:test bash -c "
            # Run bootstrap first
            cp /home/kdev/workspaces/.devcontainer/bootstrap-pyenv.sh /tmp/
            chmod +x /tmp/bootstrap-pyenv.sh
            /tmp/bootstrap-pyenv.sh

            # Verify key dependencies are installed
            dpkg -l | grep -E 'libssl-dev|zlib1g-dev|libreadline-dev|libffi-dev'
            echo 'SUCCESS: pyenv dependencies verified'
          "

      - name: Test bootstrap script idempotency
        run: |
          docker run --rm --user kdev -v ${{ github.workspace }}:/home/kdev/workspaces cpp-arm-dev:test bash -c "
            # Copy bootstrap script
            cp /home/kdev/workspaces/.devcontainer/bootstrap-pyenv.sh /tmp/
            chmod +x /tmp/bootstrap-pyenv.sh

            # Run twice - second run should detect existing installation
            /tmp/bootstrap-pyenv.sh
            echo '--- Running bootstrap again (should detect existing) ---'
            /tmp/bootstrap-pyenv.sh
            echo 'SUCCESS: Bootstrap script is idempotent'
          "

      - name: Test welcome message includes bootstrap info
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            /home/kdev/.welcome | grep -i 'bootstrap-pyenv.sh' && echo 'SUCCESS: Welcome message updated' || { echo 'FAIL: Welcome message not updated'; exit 1; }
          "

      - name: Test devcontainer setup script includes pyenv
        run: |
          docker run --rm --user kdev -v ${{ github.workspace }}:/home/kdev/workspaces cpp-arm-dev:test bash -c "
            test -f /home/kdev/workspaces/.devcontainer/setup.sh || { echo 'FAIL: Setup script missing'; exit 1; }
            grep -i 'bootstrap-pyenv.sh' /home/kdev/workspaces/.devcontainer/setup.sh && echo 'SUCCESS: Setup script includes pyenv bootstrap' || { echo 'FAIL: Setup script not updated'; exit 1; }
          "

      - name: Test image size optimization
        run: |
          # Get image size and verify it's reasonable (should be around 2.06GB, not 2.68GB)
          SIZE=$(docker images cpp-arm-dev:test --format "table {{.Size}}" | tail -n 1)
          echo "Image size: $SIZE"
          # This is informational - we'll just log the size for verification
          echo "SUCCESS: Image built with optimized size: $SIZE"

      - name: Test 32-bit and 64-bit compilation support
        run: |
          docker run --rm --user kdev cpp-arm-dev:test bash -c "
            echo '=== Testing GCC 14 Multilib Support ==='

            # Create test program
            cat > /tmp/test.c << 'EOF'
          #include <stdio.h>
          int main() {
              printf(\"Hello from %zu-bit program\\n\", sizeof(void*) * 8);
              return 0;
          }
          EOF

            echo ''
            echo '=== 64-bit Compilation Test ==='
            gcc-14 -m64 -o /tmp/test64 /tmp/test.c
            file /tmp/test64 | grep -q 'x86-64' && echo 'SUCCESS: 64-bit binary created' || { echo 'FAIL: Not a 64-bit binary'; exit 1; }
            /tmp/test64

            echo ''
            echo '=== 32-bit Compilation Test ==='
            gcc-14 -m32 -o /tmp/test32 /tmp/test.c
            file /tmp/test32 | grep -q '80386' && echo 'SUCCESS: 32-bit binary created' || { echo 'FAIL: Not a 32-bit binary'; exit 1; }
            echo 'SUCCESS: 32-bit binary compiles (execution requires 32-bit libs at runtime)'

            echo ''
            echo '=== Using default gcc (should be gcc-14) ==='
            gcc -m64 -o /tmp/test64_default /tmp/test.c
            file /tmp/test64_default | grep -q 'x86-64' && echo 'SUCCESS: Default gcc 64-bit works' || { echo 'FAIL'; exit 1; }
            /tmp/test64_default

            gcc -m32 -o /tmp/test32_default /tmp/test.c
            file /tmp/test32_default | grep -q '80386' && echo 'SUCCESS: Default gcc 32-bit works' || { echo 'FAIL'; exit 1; }

            echo ''
            echo '=== C++ Compilation Tests ==='
            cat > /tmp/test.cpp << 'EOF'
          #include <iostream>
          int main() {
              std::cout << \"C++14 test: \" << sizeof(void*) * 8 << \"-bit program\" << std::endl;
              return 0;
          }
          EOF

            g++-14 -std=c++14 -m64 -o /tmp/testcpp64 /tmp/test.cpp
            /tmp/testcpp64
            echo 'SUCCESS: C++ 64-bit compilation works'

            g++-14 -std=c++14 -m32 -o /tmp/testcpp32 /tmp/test.cpp
            file /tmp/testcpp32 | grep -q '80386' && echo 'SUCCESS: C++ 32-bit compilation works' || { echo 'FAIL'; exit 1; }

            echo ''
            echo '=== Cleanup ==='
            rm -f /tmp/test.c /tmp/test.cpp /tmp/test64 /tmp/test32 /tmp/test64_default /tmp/test32_default /tmp/testcpp64 /tmp/testcpp32
            echo 'All GCC 14 multilib tests passed!'
          "

      - name: Test kdev user configuration
        run: |
          docker run --rm --user kdev cpp-arm-dev:test whoami
          docker run --rm --user kdev cpp-arm-dev:test id
          docker run --rm --user kdev cpp-arm-dev:test echo $SHELL

      - name: Test zsh and Oh My Zsh
        run: |
          docker run --rm --user kdev cpp-arm-dev:test zsh --version
          docker run --rm --user kdev cpp-arm-dev:test ls -la /home/kdev/.oh-my-zsh

      - name: Test sudo access
        run: |
          docker run --rm --user kdev cpp-arm-dev:test sudo whoami

      - name: Test devcontainer configuration
        run: |
          docker run --rm --user kdev -v ${{ github.workspace }}:/home/kdev/workspaces cpp-arm-dev:test bash -c "
            # Check devcontainer.json exists and has pyenv bootstrap
            test -f /home/kdev/workspaces/.devcontainer/devcontainer.json || { echo 'FAIL: devcontainer.json missing'; exit 1; }
            grep -i 'bootstrap-pyenv.sh' /home/kdev/workspaces/.devcontainer/devcontainer.json && echo 'SUCCESS: devcontainer.json includes pyenv bootstrap' || { echo 'FAIL: devcontainer.json not updated'; exit 1; }
          "
